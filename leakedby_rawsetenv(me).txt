--[[
	WARNING: Heads up! This script has not been verified by ScriptBlox. Use at your own risk!
]]
-- opensourced by _rawsetenv

-- enjoy skidders

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/weakhoes/Roblox-UI-Libs/refs/heads/main/Venus%20Lib/Venus%20Lib%20Source.lua"))()
local FoodItems = workspace:WaitForChild("Items")
local CharactersFolder = workspace:WaitForChild("Characters")
local watermark = library:Watermark("FeykHub | best script tbh")

local main = library:Load{
    Name = "FeykHub",
    SizeX = 600,
    SizeY = 650,
    Theme = "Midnight",
    Extension = "json",
    Folder = "YoHub"
}

local tab = main:Tab("Main")

local section = tab:Section{
    Name = "Teleport Section",
    Side = "Left"
}

local label = section:Label("Teleports")

section:Button{
    Name = "Teleport Food Ontop Fire",
    Callback = function()
        for _, item in pairs(FoodItems:GetChildren()) do
            if item.Name == "Carrot" or item.Name == "Berry" or item.Name == "Morsel" or item.Name == "Steak" or item.Name == "Chili" then
                if item:IsA("BasePart") then
                    item.CFrame = CFrame.new(0, 20, 0)
                elseif item:IsA("Model") and item.PrimaryPart then
                    item:SetPrimaryPartCFrame(CFrame.new(0, 20, 0))
                end
            end
        end
    end
}

section:Button{
    Name = "Burn Burnables In Fire",
    Callback = function()
        for _, item in pairs(FoodItems:GetChildren()) do
            if item.Name == "Log" or item.Name == "Fuel Canister" or item.Name == "Coal" or item.Name == "Oil Barrel" or item.Name == "Cultist" or item.Name == "Crossbow Cultist" or item.Name == "Alien" then
                if item:IsA("BasePart") then
                    item.CFrame = CFrame.new(0, 15, 0)
                elseif item:IsA("Model") and item.PrimaryPart then
                    item:SetPrimaryPartCFrame(CFrame.new(0, 15, 0))
                end
            end
        end
    end
}

section:Button{
    Name = "Teleport Logs In Shredder",
    Callback = function()
        for _, item in pairs(FoodItems:GetChildren()) do
            if item.Name == "Log" then
                if item:IsA("BasePart") then
                    item.CFrame = CFrame.new(20.277976989746094, 5.1810314655303955, -5.237123012542725)
                elseif item:IsA("Model") and item.PrimaryPart then
                    item:SetPrimaryPartCFrame(CFrame.new(20.277976989746094, 5.1810314655303955, -5.237123012542725))
                end
            end
        end
    end
}

section:Button{
    Name = "Teleport Shredables In Shredder",
    Callback = function()
        for _, item in pairs(FoodItems:GetChildren()) do
            if item.Name == "Broken Fan" or item.Name == "Old Radio" or item.Name == "Sheet Metal" or item.Name == "Bolt" or item.Name == "Tyre" or item.Name == "Broken Microwave" or item.Name == "UFO Junk" or item.Name == "UFO Scrap" or item.Name == "Cultist Gem" then
                if item:IsA("BasePart") then
                    item.CFrame = CFrame.new(20.277976989746094, 5.1810314655303955, -5.237123012542725)
                elseif item:IsA("Model") and item.PrimaryPart then
                    item:SetPrimaryPartCFrame(CFrame.new(20.277976989746094, 5.1810314655303955, -5.237123012542725))
                end
            end
        end
    end
}

section:Button{
    Name = "Teleport Lost Children Ontop Fire",
    Callback = function()
        for _, item in pairs(CharactersFolder:GetChildren()) do
            if item.Name == "Lost Child" or item.Name == "Lost Child2" or item.Name == "Lost Child3" or item.name == "Lost Child4" then
                if item:IsA("BasePart") then
                    item.CFrame = CFrame.new(0, 15, 0)
                elseif item:IsA("Model") and item.PrimaryPart then
                    item:SetPrimaryPartCFrame(CFrame.new(0, 20, 0))
                end
            end
        end
    end
}

section:Button{
    Name = "Teleport Ammo Ontop Fire",
    Callback = function()
        for _, item in pairs(FoodItems:GetChildren()) do
            if item.Name == "Revolver Ammo" or item.Name == "Rifle Ammo" then
                if item:IsA("BasePart") then
                    item.CFrame = CFrame.new(0, 15, 0)
                elseif item:IsA("Model") and item.PrimaryPart then
                    item:SetPrimaryPartCFrame(CFrame.new(0, 15, 0))
                end
            end
        end
    end
}



section:Button{
    Name = "Teleport Pelts Ontop Fire",
    Callback = function()
        for _, item in pairs(FoodItems:GetChildren()) do
            if item.Name == "Wolf Pelt" or item.Name == "Alpha Wolf Pelt" then
                if item:IsA("BasePart") then
                    item.CFrame = CFrame.new(0, 15, 0)
                elseif item:IsA("Model") and item.PrimaryPart then
                    item:SetPrimaryPartCFrame(CFrame.new(0, 15, 0))
                end
            end
        end
    end
}

section:Button{
    Name = "Bring Saplings",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")

        local saplingsFolder = workspace:FindFirstChild("Items") and workkspace.Items:FindFirstChild("Sapling")
        if not saplingsFolder then return end

        for _, sapling in pairs(saplingsFolder:GetChildren()) do
            if sapling:IsA("BasePart") then
                sapling.CFrame = hrp.CFrame + Vector3.new(0, 5, 0)
            elseif sapling:IsA("Model") and sapling.PrimaryPart then
                sapling:SetPrimaryPartCFrame(hrp.CFrame + Vector3.new(0, 5, 0))
            end
        end
    end
}




section:Button{
    Name = "Bring Small Tree",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local smallTreeFolder = workspace:FindFirstChild("Map") and workspace.Map:FindFirstChild("Foliage") and workspace.Map.Foliage:FindFirstChild("Small Tree")
        if not smallTreeFolder then return end

        for _, tree in ipairs(smallTreeFolder:GetChildren()) do
            if tree:IsA("BasePart") then
                tree.CFrame = hrp.CFrame + Vector3.new(5, 5, 0)
            elseif tree:IsA("Model") and tree.PrimaryPart then
                tree:SetPrimaryPartCFrame(hrp.CFrame + Vector3.new(5, 5, 0))
            end
        end
    end
}






local seperator = section:Separator("Player Teleports")




section:Button{
    Name = "Teleport Ontop Fire",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        hrp.CFrame = CFrame.new(0, 20, 0)
    end
}

section:Button{
    Name = "Teleport Ontop Pelt Trader",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        local peltTraderModel = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild("Pelt Trader")
        if peltTraderModel then
            local peltTraderHRP = peltTraderModel:FindFirstChild("HumanoidRootPart")
            if peltTraderHRP then
                hrp.CFrame = peltTraderHRP.CFrame + Vector3.new(0, 5, 0)
            end
        end
    end
}



section:Button{
    Name = "Teleport Ontop Carvan",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        local carvanModel = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild("HorseAndCaravan")
        if carvanModel then
            local peltTraderHRP = carvanModel:FindFirstChild("HumanoidRootPart")
            if peltTraderHRP then
                hrp.CFrame = peltTraderHRP.CFrame + Vector3.new(0, 5, 0)
            end
        end
    end
}


section:Button{
    Name = "[PATCHED] Teleport Player Bodies Ontop Fire",
    Callback = function()
        local CharactersFolder = workspace:WaitForChild("Characters")

        for _, item in pairs(CharactersFolder:GetChildren()) do
            if item:IsA("Model") and item.Name:find("Body") then
                local rootPart = item:FindFirstChild("HumanoidRootPart") or item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")
                if rootPart then
                    rootPart.CFrame = CFrame.new(0, 15, 0)
                end
            end
        end
    end
}






section:Button{
    Name = "[PATCHED] Bring Player Bodies",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        local CharactersFolder = workspace:WaitForChild("Characters")

        for _, item in pairs(CharactersFolder:GetChildren()) do
            if item:IsA("Model") and item.Name:find("Body") then
                local rootPart = item:FindFirstChild("HumanoidRootPart") or item.PrimaryPart or item:FindFirstChildWhichIsA("BasePart")
                if rootPart then
                    rootPart.CFrame = hrp.CFrame * CFrame.new(0, 0, -3) -- slightly in front of player
                end
            end
        end
    end
}







--[[

local section = tab:Section{
    Name = "ESP",
    Side = "Left"
}












local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local CharactersFolder = workspace:WaitForChild("Characters")

local espEnabled = false
local labels = {}
local espColor = Color3.fromRGB(255, 165, 0)

local childNames = {
    "Lost Child",
    "Lost Child2",
    "Lost Child3",
    "Lost Child4"
}

local function createLabel(text)
    local label = Drawing.new("Text")
    label.Size = 14
    label.Center = true
    label.Outline = true
    label.Text = text
    label.Color = espColor
    label.Visible = espEnabled
    return label
end

local function updateESP()
    for _, name in ipairs(childNames) do
        local model = CharactersFolder:FindFirstChild(name)
        if model and model:IsA("Model") then
            local part = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
            if part then
                if not labels[name] then
                    labels[name] = createLabel(name)
                end
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position + Vector3.new(0, 3, 0))
                local label = labels[name]
                label.Visible = espEnabled and onScreen
                if onScreen then
                    label.Position = Vector2.new(screenPos.X, screenPos.Y)
                end
            end
        elseif labels[name] then
            labels[name]:Remove()
            labels[name] = nil
        end
    end
end

RunService.RenderStepped:Connect(updateESP)

section:Toggle{
    Name = "Child ESP",
    Flag = "ChildESP",
    Callback = function(state)
        espEnabled = state
        for _, label in pairs(labels) do
            label.Visible = state
        end
    end
}




local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local CharactersFolder = workspace:WaitForChild("Characters")

local hostileESPEnabled = false
local hostileLabels = {}
local hostileNames = {
    ["Wolf"] = true,
    ["Polar bear"] = true,
    ["Alpha Wolf"] = true,
	["Alien"] = true,
	["Cultist"] = true,
	["Crossbow Cultist"] = true,

}

local function createHostileLabel(text)
    local label = Drawing.new("Text")
    label.Size = 14
    label.Center = true
    label.Outline = true
    label.Color = Color3.fromRGB(255, 0, 0)  -- Red color
    label.Text = text
    label.Visible = hostileESPEnabled
    return label
end

local function updateHostileESP()
    for _, entity in ipairs(CharactersFolder:GetChildren()) do
        if hostileNames[entity.Name] and entity:IsA("Model") then
            local charm = entity:FindFirstChild("Charm") or entity:FindFirstChildWhichIsA("BasePart")
            if charm then
                if not hostileLabels[entity] then
                    hostileLabels[entity] = createHostileLabel(entity.Name)
                end
                local screenPos, onScreen = Camera:WorldToViewportPoint(charm.Position + Vector3.new(0, 3, 0))
                local label = hostileLabels[entity]
                label.Visible = hostileESPEnabled and onScreen
                if onScreen then
                    label.Position = Vector2.new(screenPos.X, screenPos.Y)
                end
            end
        end
    end

    for entity, label in pairs(hostileLabels) do
        if not entity:IsDescendantOf(CharactersFolder) then
            label:Remove()
            hostileLabels[entity] = nil
        end
    end
end

RunService.RenderStepped:Connect(updateHostileESP)

section:Toggle{
    Name = "Hostile ESP",
    Flag = "HostileESP",
    Callback = function(state)
        hostileESPEnabled = state
        for _, label in pairs(hostileLabels) do
            label.Visible = state
        end
    end
}













local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local CharactersFolder = workspace:WaitForChild("Characters")

local friendlyESPEnabled = false
local friendlyLabels = {}
local targetName = "Bunny"

local function createFriendlyLabel(text)
    local label = Drawing.new("Text")
    label.Size = 14
    label.Center = true
    label.Outline = true
    label.Color = Color3.fromRGB(0, 255, 0) -- Red label
    label.Text = text
    label.Visible = friendlyESPEnabled
    return label
end

local function updateFriendlyESP()
    for _, entity in ipairs(CharactersFolder:GetChildren()) do
        if entity.Name == targetName and entity:IsA("Model") then
            local charm = entity:FindFirstChild("Charm") or entity:FindFirstChildWhichIsA("BasePart")
            if charm then
                if not friendlyLabels[entity] then
                    friendlyLabels[entity] = createFriendlyLabel(entity.Name)
                end
                local screenPos, onScreen = Camera:WorldToViewportPoint(charm.Position + Vector3.new(0, 3, 0))
                local label = friendlyLabels[entity]
                label.Visible = friendlyESPEnabled and onScreen
                if onScreen then
                    label.Position = Vector2.new(screenPos.X, screenPos.Y)
                end
            end
        end
    end

    for entity, label in pairs(friendlyLabels) do
        if not entity:IsDescendantOf(CharactersFolder) then
            label:Remove()
            friendlyLabels[entity] = nil
        end
    end
end

RunService.RenderStepped:Connect(updateFriendlyESP)

section:Toggle{
    Name = "Friendly ESP",
    Flag = "FriendlyESP",
    Callback = function(state)
        friendlyESPEnabled = state
        for _, label in pairs(friendlyLabels) do
            label.Visible = state
        end
    end
}





local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local CharactersFolder = workspace:WaitForChild("Characters")

local deerESPEnabled = false
local deerLabels = {}
local targetName = "Deer"

local function createDeerLabel(text)
    local label = Drawing.new("Text")
    label.Size = 14
    label.Center = true
    label.Outline = true
    label.Color = Color3.fromRGB(255, 255, 0) -- Yellow
    label.Text = text
    label.Visible = deerESPEnabled
    return label
end

local function updateDeerESP()
    for _, entity in ipairs(CharactersFolder:GetChildren()) do
        if entity.Name == targetName and entity:IsA("Model") then
            local charm = entity:FindFirstChild("Charm") or entity:FindFirstChildWhichIsA("BasePart")
            if charm then
                if not deerLabels[entity] then
                    deerLabels[entity] = createDeerLabel(entity.Name)
                end
                local screenPos, onScreen = Camera:WorldToViewportPoint(charm.Position + Vector3.new(0, 3, 0))
                local label = deerLabels[entity]
                label.Visible = deerESPEnabled and onScreen
                if onScreen then
                    label.Position = Vector2.new(screenPos.X, screenPos.Y)
                end
            end
        end
    end

    for entity, label in pairs(deerLabels) do
        if not entity:IsDescendantOf(CharactersFolder) then
            label:Remove()
            deerLabels[entity] = nil
        end
    end
end

RunService.RenderStepped:Connect(updateDeerESP)

section:Toggle{
    Name = "Deer ESP",
    Flag = "DeerESP",
    Callback = function(state)
        deerESPEnabled = state
        for _, label in pairs(deerLabels) do
            label.Visible = state
        end
    end
}


]]--





















local section = tab:Section{
    Name = "Menu Section",
    Side = "Left"
}

section:Button{
    Name = "Destroy UI",
    Callback  = function()
        library:Unload()
    end
}


--[[
local section = tab:Section{
    Name = "Test Section",
    Side = "Right"
}

section:Button{
    Name = "Button",
    Callback  = function()
        print("Button clicked")
    end
}

local seperator = section:Separator("Separator")
local toggle = section:Toggle{
    Name = "Toggle",
    Flag = "Toggle 1",
    Callback  = function(bool)
        print("Toggle 1 is now " .. (bool and "enabled" or "disabled"))
    end
}

]]--


local section = tab:Section{
    Name = "Other",
    Side = "Right"
}


section:Button{
    Name = "Remove Fog",
    Callback = function()
        local fog = workspace:FindFirstChild("Map")
        if fog then
            fog = fog:FindFirstChild("Boundaries")
            if fog then
                fog = fog:FindFirstChild("Fog")
                if fog and fog:IsA("Model") then
                    fog:Destroy()
                end
            end
        end
    end
}

section:Button{
    Name = "Enable Fullbright",
    Callback = function()
        local lighting = game:GetService("Lighting")

        -- Set basic fullbright properties
        lighting.Brightness = 2
        lighting.ClockTime = 14 -- 14 = 2 PM
        lighting.FogEnd = 1e10 -- basically disables fog
        lighting.GlobalShadows = false
        lighting.OutdoorAmbient = Color3.new(1, 1, 1)
        lighting.Ambient = Color3.new(1, 1, 1)
        lighting.ColorShift_Top = Color3.new(0, 0, 0)
        lighting.ColorShift_Bottom = Color3.new(0, 0, 0)
    end
}

section:Button{
    Name = "Voicechat Unban",
    Callback = function()
		game:GetService("VoiceChatService"):joinVoice()
		print("Temporarly Unbanned Voicechat")
    end
}





section:Button{
    Name = "FPS Boost",
    Callback = function()
        local lighting = game:GetService("Lighting")

        lighting.GlobalShadows = false
        lighting.FogEnd = 100000
        lighting.Brightness = 1
        lighting.EnvironmentDiffuseScale = 0
        lighting.EnvironmentSpecularScale = 0

        for _, v in ipairs(game:GetDescendants()) do
            if v:IsA("BasePart") then
                v.Material = Enum.Material.Plastic
                v.Reflectance = 0
            elseif v:IsA("Decal") or v:IsA("Texture") then
                v:Destroy()
            elseif v:IsA("ParticleEmitter") or v:IsA("Trail") or v:IsA("Fire") or v:IsA("Smoke") then
                v:Destroy()
            elseif v:IsA("ShirtGraphic") or v:IsA("Shirt") or v:IsA("Pants") then
                v:Destroy()
            end
        end

        local terrain = workspace:FindFirstChildOfClass("Terrain")
        if terrain then
            terrain.WaterWaveSize = 0
            terrain.WaterWaveSpeed = 0
            terrain.WaterReflectance = 0
            terrain.WaterTransparency = 0
        end

        print("FPS Boost applied.")
    end
}





section:Button{
    Name = "Emote GUI",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/SubToy0nikos/YoHub/refs/heads/main/FEEmoteGui.lua"))()
    end
}








local virtualUser = game:GetService("VirtualUser")
local antiAFKConnection

section:Toggle{
    Name = "Anti-AFK",
    Flag = "AntiAFKToggle",
    Callback = function(state)
        if state then
            antiAFKConnection = game.Players.LocalPlayer.Idled:Connect(function()
                virtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
                task.wait(1)
                virtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
            end)
            print("Anti-AFK enabled")
        else
            if antiAFKConnection then
                antiAFKConnection:Disconnect()
                antiAFKConnection = nil
            end
            print("Anti-AFK disabled")
        end
    end
}






local section = tab:Section{
    Name = "Player",
    Side = "Right"
}





section:Slider{
    Name = "WalkSpeed",
    Min = 16,
    Max = 200,
    Default = 16,
    Increment = 1,
    Flag = "WalkSpeedSlider",
    Callback = function(value)
        local char = game.Players.LocalPlayer.Character
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.WalkSpeed = value
            end
        end
    end
}






section:Slider{
    Name = "JumpPower",
    Min = 50,
    Max = 300,
    Default = 50,
    Increment = 5,
    Flag = "JumpPowerSlider",
    Callback = function(value)
        local char = game.Players.LocalPlayer.Character
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.JumpPower = value
            end
        end
    end
}



local noclip = false
local noclipConnection

section:Toggle{
    Name = "Noclip",
    Flag = "NoclipToggle",
    Callback = function(enabled)
        noclip = enabled
        local player = game.Players.LocalPlayer
        local char = player.Character or player.CharacterAdded:Wait()

        if enabled then
            noclipConnection = game:GetService("RunService").Stepped:Connect(function()
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") and part.CanCollide then
                        part.CanCollide = false
                    end
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end
        end
    end
}




local infJump = false

section:Toggle{
    Name = "Infinite Jump",
    Flag = "InfJumpToggle",
    Callback = function(enabled)
        infJump = enabled
        local UIS = game:GetService("UserInputService")
        local player = game.Players.LocalPlayer
        local jumpConnection

        if enabled then
            jumpConnection = UIS.JumpRequest:Connect(function()
                if infJump and player.Character and player.Character:FindFirstChildOfClass("Humanoid") then
                    player.Character:FindFirstChildOfClass("Humanoid"):ChangeState("Jumping")
                end
            end)

            _G._infJumpConn = jumpConnection
        else
            if _G._infJumpConn then
                _G._infJumpConn:Disconnect()
                _G._infJumpConn = nil
            end
        end
    end
}






local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local flying = false
local flySpeed = 100
local flyDirection = Vector3.zero

UIS.InputBegan:Connect(function(input, gp)
	if gp then return end
	if not flying then return end

	if input.KeyCode == Enum.KeyCode.W then
		flyDirection = Vector3.new(0, 0, -1)
	elseif input.KeyCode == Enum.KeyCode.S then
		flyDirection = Vector3.new(0, 0, 1)
	elseif input.KeyCode == Enum.KeyCode.A then
		flyDirection = Vector3.new(-1, 0, 0)
	elseif input.KeyCode == Enum.KeyCode.D then
		flyDirection = Vector3.new(1, 0, 0)
	elseif input.KeyCode == Enum.KeyCode.Space then
		flyDirection = Vector3.new(0, 1, 0)
	elseif input.KeyCode == Enum.KeyCode.LeftControl then
		flyDirection = Vector3.new(0, -1, 0)
	end
end)

UIS.InputEnded:Connect(function(input)
	if not flying then return end
	flyDirection = Vector3.zero
end)

local function flyLoop()
	RunService:BindToRenderStep("FlyMovement", Enum.RenderPriority.Character.Value + 1, function()
		if flying and hrp and flyDirection.Magnitude > 0 then
			hrp.Velocity = (workspace.CurrentCamera.CFrame:VectorToWorldSpace(flyDirection.Unit)) * flySpeed
		elseif hrp then
			hrp.Velocity = Vector3.new(0, 0, 0)
		end
	end)
end

section:Toggle{
	Name = "Fly",
	Flag = "FlyToggle",
	Callback = function(state)
		flying = state
		if flying then
			character = player.Character or player.CharacterAdded:Wait()
			hrp = character:WaitForChild("HumanoidRootPart")
			flyLoop()
		else
			RunService:UnbindFromRenderStep("FlyMovement")
			if hrp then hrp.Velocity = Vector3.zero end
		end
	end
}

section:Slider{
	Name = "Fly Speed",
	Min = 10,
	Max = 500,
	Default = 100,
	Increment = 10,
	Flag = "FlySpeedSlider",
	Callback = function(value)
		flySpeed = value
	end
}













local seperator = section:Separator("Kills")


section:Button{
    Name = "[PATCHED] Kill Cultists",
    Callback = function()
        for _, item in pairs(CharactersFolder:GetChildren()) do
            if item.Name == "Cultist" or item.Name == "Crossbow Cultist" and item:IsA("Model") then
                local hrp = item:FindFirstChild("HumanoidRootPart")
                if hrp and hrp:IsA("BasePart") then
                    hrp.CFrame = CFrame.new(0, -500, 0)
                end
            elseif item.Name == "Cultrist" or item.Name == "Crossbow Cultrist" and item:IsA("BasePart") then
                item.CFrame = CFrame.new(0, -500, 0)
            end
        end
    end
}

section:Button{
    Name = "[PATCHED] Kill Deer",
    Callback = function()
        for _, item in pairs(CharactersFolder:GetChildren()) do
            if item.Name == "Deer" and item:IsA("Model") then
                local hrp = item:FindFirstChild("HumanoidRootPart")
                if hrp and hrp:IsA("BasePart") then
                    hrp.CFrame = CFrame.new(0, -500, 0)
                end
            elseif item.Name == "Deer" and item:IsA("BasePart") then
                item.CFrame = CFrame.new(0, -500, 0)
            end
        end
    end
}






local seperator = section:Separator("W.I.P STUFF")




section:Button{
    Name = "W.I.P Chest Instant Interact",
    Callback = function()
        local ProximityPromptService = game:GetService("ProximityPromptService")

        ProximityPromptService.PromptButtonHoldBegan:Connect(function(prompt, player)
            if prompt and prompt:IsA("ProximityPrompt") then
                local success, err = pcall(function()
                    prompt:InputHoldBegin()
                    prompt:InputHoldEnd()
                    prompt:TriggerTriggered()
                end)
                if not success then
                    if fireproximityprompt then
                        fireproximityprompt(prompt)
                    end
                end
            end
        end)

        print("Instant interact enabled.")
    end
}






section:Button{
    Name = "W.I.P Plant Saplings",
    Callback = function()
        print("IG NOT COMING SOON CAUSE THIS IS HARD ASF")
    end
}



















local section = tab:Section{
    Name = "Kill Aura",
    Side = "Right"
}




local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents")
local player = Players.LocalPlayer

local killAuraToggle = false
local killAuraRadius = 20

local toolsDamageIDs = {
    ["Old Axe"] = "1_8982038982",
    ["Good Axe"] = "112_8982038982",
    ["Strong Axe"] = "116_8982038982",
    ["Chainsaw"] = "647_8992824875",
    ["Spear"] = "196_8999010016"
}

local function getAnyToolWithDamageID()
    for toolName, damageID in pairs(toolsDamageIDs) do
        local tool = player.Inventory:FindFirstChild(toolName)
        if tool then
            return tool, damageID
        end
    end
    return nil, nil
end

local function equipTool(tool)
    if tool then
        RemoteEvents.EquipItemHandle:FireServer("FireAllClients", tool)
    end
end

local function unequipTool(tool)
    if tool then
        RemoteEvents.UnequipItemHandle:FireServer("FireAllClients", tool)
    end
end

local function killAuraLoop()
    task.spawn(function()
        while killAuraToggle do
            local character = player.Character or player.CharacterAdded:Wait()
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then task.wait(0.5) continue end

            local tool, damageID = getAnyToolWithDamageID()
            if tool and damageID then
                equipTool(tool)

                for _, mob in ipairs(Workspace.Characters:GetChildren()) do
                    if mob:IsA("Model") and mob ~= character then
                        local part = mob:FindFirstChild("HumanoidRootPart") or mob:FindFirstChildWhichIsA("BasePart")
                        if part and (part.Position - hrp.Position).Magnitude <= killAuraRadius then
                            pcall(function()
                                RemoteEvents.ToolDamageObject:InvokeServer(
                                    mob,
                                    tool,
                                    damageID,
                                    CFrame.new(part.Position)
                                )
                            end)
                        end
                    end
                end
            end
            task.wait(0.1)
        end

        local tool = getAnyToolWithDamageID()
        unequipTool(tool)
    end)
end

section:Toggle{
    Name = "Kill Aura",
    Flag = "KillAuraToggle",
    Callback = function(state)
        killAuraToggle = state
        if killAuraToggle then
            killAuraLoop()
            print("Kill Aura enabled")
        else
            print("Kill Aura disabled")
        end
    end
}

section:Slider{
    Name = "Kill Aura Radius",
    Min = 10,
    Max = 100,
    Default = 20,
    Increment = 10,
    Flag = "KillAuraRadius",
    Callback = function(value)
        killAuraRadius = value
        print("Kill Aura radius set to", value)
    end
}










local togglepicker1 = toggle:ColorPicker{
    Default = Color3.fromRGB(255, 0, 0), 
    Flag = "Toggle 1 Picker 1", 
    Callback = function(color)
        print("Toggle 1 Picker 1 is now " .. string.format("%s, %s, %s, %s", math.round(color.R * 255), math.round(color.G * 255), math.round(color.B * 255), math.floor(color.A * 100) / 100))
    end
}


local togglepicker2 = toggle:ColorPicker{
    Default = Color3.fromRGB(0, 255, 0), 
    Flag = "Toggle 1 Picker 2", 
    Callback = function(color)
        print("Toggle 1 Picker 2 is now " .. string.format("%s, %s, %s, %s", math.round(color.R * 255), math.round(color.G * 255), math.round(color.B * 255), math.floor(color.A * 100) / 100))
    end
}

--togglepicker2:Set(Color3.fromRGB(255, 255, 255))

--toggle:Toggle(true)

local toggle2 = section:Toggle{
    Name = "Toggle 2",
    Flag = "Toggle 2",
    --Default = true,
    Callback  = function(bool)
        print("Toggle 2 is now " .. (bool and "enabled" or "disabled"))
    end
}

toggle2:Keybind{
    --Default = Enum.KeyCode.A,
    Blacklist = {Enum.UserInputType.MouseButton1},
    Flag = "Toggle 2 Keybind 1",
    Mode = "Toggle", -- mode to nil if u dont want it to toggle the toggle
    Callback = function(key, fromsetting)
        if fromsetting then
            print("Toggle 2 Keybind 1 is now " .. tostring(key))
        else
            print("Toggle 2 Keybind 1 was pressed")
        end
    end
}

local toggle3 = section:Toggle{
    Name = "Toggle 3",
    Flag = "Toggle 3",
    --Default = true,
    Callback  = function(bool)
        print("Toggle 3 is now " .. (bool and "enabled" or "disabled"))
    end
}

toggle3:Slider{
    Text = "[value]/5",
    --Default = 5,
    Min = 0,
    Max = 5,
    Float = 0.5,
    Flag = "Slider 1",
    Callback = function(value)
        print("Toggle 3 Slider 1 is now " .. value)
    end
}

local toggle4 = section:Toggle{
    Name = "Toggle 4",
    Flag = "Toggle 4",
    --Default = true,
    Callback  = function(bool)
        print("Toggle 4 is now " .. (bool and "enabled" or "disabled"))
    end
}

toggle4:Dropdown{
    --Default = "Option 1",
    Content = {
        "Option 1",
        "Option 2",
        "Option 3"
    },
    --Max = 5, -- turns into multidropdown
    --Scrollable = true, -- makes it scrollable
    --ScrollingMax = 5, -- caps the amount it contains before scrolling
    Flag = "Dropdown 1",
    Callback = function(option)
        print("Dropdown 1 is now " .. tostring(option))
    end
}


local box = section:Box{
    Name = "Box",
    --Default = "hi",
    Placeholder = "Box Placeholder",
    Flag = "Box 1",
    Callback = function(text)
        print("Box 1 is now " .. text)
    end
}

--box:Set("New box text")

local slider = section:Slider{
    Name = "Slider",
    Text = "[value]/1",
    --Default = 0.1,
    Min = 0,
    Max = 1,
    Float = 0.1,
    Flag = "Slider 1",
    Callback = function(value)
        print("Slider 1 is now " .. value)
    end
}

--slider:Set(1)

local dropdown = section:Dropdown{
    Name = "Dropdown",
    --Default = "Option 1",
    Content = {
        "Option 1",
        "Option 2",
        "Option 3"
    },
    Flag = "Dropdown 1",
    Callback = function(option)
        print("Dropdown 1 is now " .. tostring(option))
    end
}


dropdown:Set() -- using this without any args or with wrong args will unset the dropdown
--dropdown:Set("option 6") wont work and will unset

dropdown:Refresh{
    "Refreshed option 1",
    "Refreshed option 2",
    "Refreshed option 3"
}

dropdown:Set("Refreshed option 1")

dropdown:Add("Option 4")

dropdown:Remove("Option 4")

local multidropdown = section:Dropdown{
    Name = "Multi dropdown",
    --Default = {"Option 1"},
    Max = 3, -- makes it multi
    Content = {
        "Option 1",
        "Option 2",
        "Option 3"
    },
    Flag = "Multi dropdown 1",
    Callback = function(option)
        print("Multi dropdown 1 is now " .. table.concat(option, ", "))
    end
}

multidropdown:Set() -- using this without any args or with wrong args will unset the dropdown
multidropdown:Set{} -- using this without any args or with wrong args will unset the dropdown
--multidropdown:Set{"option 12321313"} wont work and will unset
--multidropdown:Set("hello") wont work and will unset

multidropdown:Refresh{
    "Refreshed option 1",
    "Refreshed option 2",
    "Refreshed option 3",
    "Refreshed option 4"
}

multidropdown:Set{
    "Refreshed option 1",
    "Refreshed option 2"
}

multidropdown:Add("Option 5")

multidropdown:Remove("Option 5")

local dropdown = section:Dropdown{
    Name = "Scrolling Dropdown",
    --Default = "Option 1",
    Scrollable = true,
    ScrollingMax = 5,
    Content = {
        "Option 1",
        "Option 2",
        "Option 3",
        "Option 4",
        "Option 5",
        "Option 6",
        "Option 7"
    },
    Flag = "Scrolling Dropdown 1",
    Callback = function(option)
        print("Scrolling Dropdown 1 is now " .. tostring(option))
    end
}

local colorpicker = section:ColorPicker{
    Name = "Color picker",
    Default = Color3.fromRGB(0, 255, 0),
    Flag = "Color picker 1",
    Callback = function(color)
        print("Color picker 1 is now: " .. string.format("%s, %s, %s, %s", math.round(color.R * 255), math.round(color.G * 255), math.round(color.B * 255), math.floor(color.A * 100) / 100))
    end
}

--colorpicker:Set(Color3.fromRGB(255, 255, 255))

local colorpickerpicker1 = colorpicker:ColorPicker{
    Default = Color3.fromRGB(0, 255, 255),
    DefaultAlpha = 0.5,
    Flag = "Color picker picker 1",
    Callback = function(color)
        print("Color picker 1 picker 1 is now: " .. string.format("%s, %s, %s, %s", math.round(color.R * 255), math.round(color.G * 255), math.round(color.B * 255), math.floor(color.A * 100) / 100))
    end
}

--colorpickerpicker1:Set(Color3.fromRGB(255, 255, 255))

local colorpickerpicker2 = colorpicker:ColorPicker{
    Default = Color3.fromRGB(255, 255, 255),
    Flag = "Color picker picker 2",
    Callback = function(color)
        print("Color picker 1 picker 2 is now " .. string.format("%s, %s, %s, %s", math.round(color.R * 255), math.round(color.G * 255), math.round(color.B * 255), math.floor(color.A * 100) / 100))
    end
}

--colorpickerpicker2:Set(Color3.fromRGB(255, 255, 255))

local keybind = section:Keybind{
    Name = "Keybind",
    --Default = Enum.KeyCode.A,
    --Blacklist = {Enum.UserInputType.MouseButton1, Enum.UserInputType.MouseButton2},
    Flag = "Keybind 1",
    Callback = function(key, fromsetting)
        if fromsetting then
            print("Keybind 1 is now " .. tostring(key))
        else
            print("Keybind 1 was pressed")
        end
    end
}


--library:SaveConfig("config", true) -- universal config
--library:SaveConfig("config") -- game specific config
--library:DeleteConfig("config", true) -- universal config
--library:DeleteConfig("config") -- game specific config
--library:GetConfigs(true) -- return universal and game specific configs (table)
--library:GetConfigs() -- return game specific configs (table)
--library:LoadConfig("config", true) -- load universal config
--library:LoadConfig("config") -- load game specific config

local configs = main:Tab("Configuration")

local themes = configs:Section{Name = "Theme", Side = "Left"}

local themepickers = {}

local themelist = themes:Dropdown{
    Name = "Theme",
    Default = library.currenttheme,
    Content = library:GetThemes(),
    Flag = "Theme Dropdown",
    Callback = function(option)
        if option then
            library:SetTheme(option)

            for option, picker in next, themepickers do
                picker:Set(library.theme[option])
            end
        end
    end
}

library:ConfigIgnore("Theme Dropdown")

local namebox = themes:Box{
    Name = "Custom Theme Name",
    Placeholder = "Custom Theme",
    Flag = "Custom Theme"
}

library:ConfigIgnore("Custom Theme")

themes:Button{
    Name = "Save Custom Theme",
    Callback = function()
        if library:SaveCustomTheme(library.flags["Custom Theme"]) then
            themelist:Refresh(library:GetThemes())
            themelist:Set(library.flags["Custom Theme"])
            namebox:Set("")
        end
    end
}

local customtheme = configs:Section{Name = "Custom Theme", Side = "Right"}

themepickers["Accent"] = customtheme:ColorPicker{
    Name = "Accent",
    Default = library.theme["Accent"],
    Flag = "Accent",
    Callback = function(color)
        library:ChangeThemeOption("Accent", color)
    end
}

library:ConfigIgnore("Accent")

themepickers["Window Background"] = customtheme:ColorPicker{
    Name = "Window Background",
    Default = library.theme["Window Background"],
    Flag = "Window Background",
    Callback = function(color)
        library:ChangeThemeOption("Window Background", color)
    end
}

library:ConfigIgnore("Window Background")

themepickers["Window Border"] = customtheme:ColorPicker{
    Name = "Window Border",
    Default = library.theme["Window Border"],
    Flag = "Window Border",
    Callback = function(color)
        library:ChangeThemeOption("Window Border", color)
    end
}

library:ConfigIgnore("Window Border")

themepickers["Tab Background"] = customtheme:ColorPicker{
    Name = "Tab Background",
    Default = library.theme["Tab Background"],
    Flag = "Tab Background",
    Callback = function(color)
        library:ChangeThemeOption("Tab Background", color)
    end
}

library:ConfigIgnore("Tab Background")

themepickers["Tab Border"] = customtheme:ColorPicker{
    Name = "Tab Border",
    Default = library.theme["Tab Border"],
    Flag = "Tab Border",
    Callback = function(color)
        library:ChangeThemeOption("Tab Border", color)
    end
}

library:ConfigIgnore("Tab Border")

themepickers["Tab Toggle Background"] = customtheme:ColorPicker{
    Name = "Tab Toggle Background",
    Default = library.theme["Tab Toggle Background"],
    Flag = "Tab Toggle Background",
    Callback = function(color)
        library:ChangeThemeOption("Tab Toggle Background", color)
    end
}

library:ConfigIgnore("Tab Toggle Background")

themepickers["Section Background"] = customtheme:ColorPicker{
    Name = "Section Background",
    Default = library.theme["Section Background"],
    Flag = "Section Background",
    Callback = function(color)
        library:ChangeThemeOption("Section Background", color)
    end
}

library:ConfigIgnore("Section Background")

themepickers["Section Border"] = customtheme:ColorPicker{
    Name = "Section Border",
    Default = library.theme["Section Border"],
    Flag = "Section Border",
    Callback = function(color)
        library:ChangeThemeOption("Section Border", color)
    end
}

library:ConfigIgnore("Section Border")

themepickers["Text"] = customtheme:ColorPicker{
    Name = "Text",
    Default = library.theme["Text"],
    Flag = "Text",
    Callback = function(color)
        library:ChangeThemeOption("Text", color)
    end
}

library:ConfigIgnore("Text")

themepickers["Disabled Text"] = customtheme:ColorPicker{
    Name = "Disabled Text",
    Default = library.theme["Disabled Text"],
    Flag = "Disabled Text",
    Callback = function(color)
        library:ChangeThemeOption("Disabled Text", color)
    end
}

library:ConfigIgnore("Disabled Text")

themepickers["Object Background"] = customtheme:ColorPicker{
    Name = "Object Background",
    Default = library.theme["Object Background"],
    Flag = "Object Background",
    Callback = function(color)
        library:ChangeThemeOption("Object Background", color)
    end
}

library:ConfigIgnore("Object Background")

themepickers["Object Border"] = customtheme:ColorPicker{
    Name = "Object Border",
    Default = library.theme["Object Border"],
    Flag = "Object Border",
    Callback = function(color)
        library:ChangeThemeOption("Object Border", color)
    end
}

library:ConfigIgnore("Object Border")

themepickers["Dropdown Option Background"] = customtheme:ColorPicker{
    Name = "Dropdown Option Background",
    Default = library.theme["Dropdown Option Background"],
    Flag = "Dropdown Option Background",
    Callback = function(color)
        library:ChangeThemeOption("Dropdown Option Background", color)
    end
}

library:ConfigIgnore("Dropdown Option Background")

local configsection = configs:Section{Name = "Configs", Side = "Left"}

local configlist = configsection:Dropdown{
    Name = "Configs",
    Content = library:GetConfigs(), -- GetConfigs(true) if you want universal configs
    Flag = "Config Dropdown"
}

library:ConfigIgnore("Config Dropdown")

local loadconfig = configsection:Button{
    Name = "Load Config",
    Callback = function()
        library:LoadConfig(library.flags["Config Dropdown"]) -- LoadConfig(library.flags["Config Dropdown"], true)  if you want universal configs
    end
}

local delconfig = configsection:Button{
    Name = "Delete Config",
    Callback = function()
        library:DeleteConfig(library.flags["Config Dropdown"]) -- DeleteConfig(library.flags["Config Dropdown"], true)  if you want universal configs
        configlist:Refresh(library:GetConfigs())
    end
}


local configbox = configsection:Box{
    Name = "Config Name",
    Placeholder = "Config Name",
    Flag = "Config Name"
}

library:ConfigIgnore("Config Name")

local save = configsection:Button{
    Name = "Save Config",
    Callback = function()
        library:SaveConfig(library.flags["Config Dropdown"] or library.flags["Config Name"]) -- SaveConfig(library.flags["Config Name"], true) if you want universal configs
        configlist:Refresh(library:GetConfigs())
    end
}

local keybindsection = configs:Section{Name = "UI Toggle Keybind", Side = "Left"}

keybindsection:Keybind{
    Name = "UI Toggle",
    Flag = "UI Toggle",
    Default = Enum.KeyCode.Insert,
    Blacklist = {Enum.UserInputType.MouseButton1, Enum.UserInputType.MouseButton2, Enum.UserInputType.MouseButton3},
    Callback = function(_, fromsetting)
        if not fromsetting then
            library:Close()
        end
    end
}

keybindsection:Keybind{
    Name = "Destroy UI",
    Flag = "Unload UI",
    Default = Enum.KeyCode.Delete,
    Blacklist = {Enum.UserInputType.MouseButton1, Enum.UserInputType.MouseButton2, Enum.UserInputType.MouseButton3},
    Callback = function(_, fromsetting)
        if not fromsetting then
            library:Unload()
        end
    end
}


local scrolling = main:Tab("Scrolling Columns")

for i = 1, 20 do
    local sec = scrolling:Section{
        Name = tostring(math.random(2000, 20000000)),
        Side = math.random(1, 2) == 1 and "Left" or "Right"
    }

    for i = 1, math.random(3, 10) do
        if math.random(1, 2) == 1 then
            sec:Label(tostring(math.random(2000, 20000000)))
        else
            sec:Button{Name = tostring(math.random(2000, 20000000))}
        end
    end
end

--library:Close()
--library:Unload()